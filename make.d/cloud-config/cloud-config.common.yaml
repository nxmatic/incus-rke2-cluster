# Common cloud-init configuration for all RKE2 nodes (masters and agents)

hostname: ${NODE_NAME}-control-node

manage_resolv_conf: true
resolv_conf:
  searchdomains:
    - mammoth-skate.ts.net

# -----------------------------------------------------------------------------
# Network configuration now provided via separate NoCloud network-config file (@codebase)
# The standalone network-config.yaml template generates the network-config seed file
# mounted at /var/lib/cloud/seed/nocloud/network-config. Since cloud-init doesn't
# properly honor the 'renderer: networkd' directive, we use bootcmd to install the
# netplan file before systemd-networkd starts.
# -----------------------------------------------------------------------------

bootcmd:
  # Install NoCloud network-config as netplan file before cloud-init processes network
  # This must run in bootcmd because write_files happens too late (after network config)
  - [ test, -f, /var/lib/cloud/seed/nocloud/network-config ]
  - [ cp, /var/lib/cloud/seed/nocloud/network-config, /etc/netplan/01-nocloud.yaml ]
  - [ chmod, '600', /etc/netplan/01-nocloud.yaml ]
  # Disable dhcpcd for vmnet0 - systemd-networkd will handle it
  - [ sh, -c, "echo 'denyinterfaces vmnet0' >> /etc/dhcpcd.conf" ]  

write_files:
  # =============================================================================
  # SYSTEM CONFIGURATION FILES
  # =============================================================================

  # Disable cloud-init network configuration to prevent conflicts with netplan/systemd-networkd
  # This prevents cloud-init from generating /etc/network/interfaces.d/50-cloud-init
  # which would start dhcpcd and conflict with systemd-networkd DHCP
  - path: /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg
    permissions: "0644"
    content: |
      network: {config: disabled}

  # systemd-networkd drop-in to set cluster-prefixed hostname for LAN DHCP
  # This ensures LAN DHCP registrations are unique per cluster (bioskop vs alcide)
  # while keeping the actual system hostname unchanged
  # Drop-in must match netplan-generated config name: 10-netplan-lan0.network
  - path: /etc/systemd/network/10-netplan-lan0.network.d/10-hostname.conf
    permissions: "0644"
    content: |
      [DHCP]
      SendHostname=yes
      Hostname=${CLUSTER_NAME}-${NODE_NAME}-control-node

  # systemd-networkd drop-in to prevent vmnet0 DHCP from installing routes/DNS
  - path: /etc/systemd/network/10-netplan-lan0.network.d/90-no-default.conf
    permissions: "0644"
    content: |
      [Network]
      DHCP=ipv4
      IPv6AcceptRA=no
      LinkLocalAddressing=ipv4
      LLMNR=yes

      [DHCP]
      UseDNS=yes

  # systemd-networkd drop-in to prevent vmnet0 DHCP from installing routes/DNS
  - path: /etc/systemd/network/10-netplan-vmnet0.network.d/90-no-default.conf
    permissions: "0644"
    content: |
      [Network]
      IPv6AcceptRA=no
      LinkLocalAddressing=ipv4

      [DHCP]
      UseRoutes=no
      UseDNS=no

  # systemd-resolved drop-in to disable LLMNR/mDNS advertising on LAN interfaces
  - path: /etc/systemd/resolved.conf.d/10-disable-llmnr-mdns.conf
    permissions: "0644"
    content: |
      [Resolve]
      LLMNR=no
      MulticastDNS=no

  # Disable IPv6 globally so nodes stay IPv4-only end-to-end (@codebase)
  - path: /etc/sysctl.d/99-disable-ipv6.conf
    permissions: "0644"
    content: |
      net.ipv6.conf.all.disable_ipv6 = 1
      net.ipv6.conf.default.disable_ipv6 = 1
      net.ipv6.conf.lo.disable_ipv6 = 1
      net.ipv6.conf.lan0.disable_ipv6 = 1
      net.ipv6.conf.vmnet0.disable_ipv6 = 1
      net.ipv6.conf.all.accept_ra = 0
      net.ipv6.conf.default.accept_ra = 0

  # Network configuration script using flox environment and yq
  - path: /usr/local/sbin/rke2-network-config
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exuo pipefail
      
      # Log all operations
      exec > >(logger -t rke2-network-config) 2>&1
      
      : "Load flox environment for yq and other tools"
      source <( flox activate --dir /var/lib/cloud/seed/nocloud )
      
      : "=== Stopping dhcpcd for vmnet0 (systemd-networkd will manage it) ==="
      # Kill dhcpcd processes for vmnet0 to prevent route conflicts
      pkill -f 'dhcpcd.*vmnet0' || true
      sleep 1
      
      : "=== Process List Before Network Config ==="
      ps -ef
      
      : "=== Applying netplan configuration ==="
      ip link set dev lan0 down || true
      ip link set dev vmnet0 down || true
      
      netplan apply
      
      : "=== Restarting systemd-networkd to ensure UseRoutes settings take effect ==="
      systemctl restart systemd-networkd
      sleep 3
      
      : "=== Verifying dhcpcd is not managing vmnet0 ==="
      if ps aux | grep -v grep | grep 'dhcpcd.*vmnet0'; then
        echo "[!] Warning: dhcpcd still managing vmnet0, killing again..."
        pkill -f 'dhcpcd.*vmnet0' || true
      else
        echo "[i] dhcpcd not managing vmnet0 (correct)"
      fi
      
      : "=== Final Network Status ==="
      ip addr show
      ip route show
      systemctl status systemd-networkd --no-pager

      : "=== Process List After Network Config ==="
      ps -ef

  # Network configuration systemd service
  - path: /etc/systemd/system/rke2-network-config.service
    permissions: "0644"
    content: |
      [Unit]
      Description=RKE2 Network Configuration Service
      After=systemd-networkd.service cloud-init.service
      Wants=systemd-networkd.service
      Before=rke2-install.service
      
      [Service]
      Type=oneshot
      ExecStart=/usr/local/sbin/rke2-network-config
      RemainAfterExit=yes
      StandardOutput=journal
      StandardError=journal
      
      [Install]
      WantedBy=multi-user.target

  # Docker CLI shim to route invocations to nerdctl for kpt functions
  - path: /usr/local/bin/docker
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -euo pipefail

      if [[ "$${1:-}" == "version" ]]; then
        echo "20.10.0"
        exit 0
      fi

      exec nerdctl "$@"

  # Shared helper to run kpt fn eval + live apply with consistent defaults
  - path: /usr/local/sbin/rke2-kpt-deploy
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exuo pipefail

      FLOX_ENV_DIR="$${FLOX_ENV_DIR:-/var/lib/rancher/rke2}"

      if [[ -z "$${RKE2_KPT_SKIP_FLOX:-}" ]]; then
        if command -v flox >/dev/null 2>&1; then
          # shellcheck disable=SC1090
          source <(flox activate --dir "$${FLOX_ENV_DIR}")
        else
          echo "[rke2-kpt-deploy] flox command not found, continuing without flox environment" >&2
        fi
      fi

      usage() {
        echo "Usage: rke2-kpt-deploy <package-path> [options] -- [setter args]" >&2
        echo >&2
        echo "Options:" >&2
        echo "  --timeout[=DURATION]   Override reconcile timeout (default: 3m or \$${KPT_LIVE_TIMEOUT})" >&2
        echo "  --skip-fn              Skip kpt fn eval (run live apply only)" >&2
        echo "  --<flag>               Additional kpt fn flags before \"--\" pass through to kpt fn eval" >&2
      }

      package_path="$${1:-}"
      if [[ -z "$${package_path}" ]]; then
        usage >&2
        exit 64
      fi
      shift

      timeout="$${KPT_LIVE_TIMEOUT:-3m}"
      run_fn=1
      fn_flags=()
      while [[ $${#} -gt 0 ]]; do
        case "$${1}" in
          --timeout=*)
            timeout="$${1#*=}"
            shift
            ;;
          --timeout)
            if [[ $${#} -lt 2 ]]; then
              echo "[rke2-kpt-deploy] --timeout requires a value" >&2
              exit 64
            fi
            timeout="$${2}"
            shift 2
            ;;
          --skip-fn)
            run_fn=0
            shift
            ;;
          --)
            shift
            break
            ;;
          *)
            fn_flags+=("$${1}")
            shift
            ;;
        esac
      done

      setter_args=("$${@}")
      fn_config_file=""
      fn_config_flag=()
      cleanup() {
        [[ -n "$${fn_config_file}" && -f "$${fn_config_file}" ]] && rm -f "$${fn_config_file}"
      }
      trap cleanup EXIT

      if (( $${#setter_args[@]} )); then
        if ! command -v yq >/dev/null 2>&1; then
          echo "[rke2-kpt-deploy] yq command is required for setter arguments" >&2
          exit 1
        fi

        fn_config_file="$(mktemp)"
        yq -n '
          .apiVersion = "v1" |
          .kind = "ConfigMap" |
          .metadata.name = "apply-setters-input" |
          .data = {}
        ' > "$${fn_config_file}"
  
        for kv in "$${setter_args[@]}"; do
          if [[ "$${kv}" != *=* ]]; then
            echo "[rke2-kpt-deploy] setter argument '$${kv}' must be key=value" >&2
            exit 64
          fi
          key="$${kv%%=*}"
          value="$${kv#*=}"
          yq eval --inplace ".data.\"$${key}\" = \"$${value}\"" "$${fn_config_file}"
        done
        fn_config_flag=(--fn-config "$${fn_config_file}")
      fi
      if [[ $${run_fn} -eq 1 ]]; then
        kpt fn render "$${package_path}" "$${fn_flags[@]}" "$${fn_config_flag[@]}"
      fi

      kpt live apply "$${package_path}" --reconcile-timeout="$${timeout}" --cache-dir=$${KPT_CACHE_DIR:-/var/lib/rancher/rke2/kpt-live-cache}

  # Wait for OpenEBS controller/CRDs to finish reconciling
  - path: /usr/local/sbin/rke2-openebs-ready-check
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exuo pipefail

      source <(flox activate --dir /var/lib/rancher/rke2)

      log() {
        echo "[rke2-openebs-ready] $$*"
      }

      wait_for_storageclass() {
        local sc="$${1:?storageclass name required}" timeout="$${2:-300}" interval="$${3:-5}"
        local start end
        start="$(date +%s)"
        end=$((start + timeout))
        while ! kubectl get storageclass "$${sc}" >/dev/null 2>&1; do
          if (( $(date +%s) >= end )); then
            log "StorageClass $${sc} not ready after $${timeout}s"
            kubectl get storageclass || true
            return 1
          fi
          log "Waiting for StorageClass $${sc}..."
          sleep "$${interval}"
        done
        log "StorageClass $${sc} detected"
        kubectl get storageclass "$${sc}"
      }

      log "Waiting for OpenEBS components..."

      kubectl wait --for=condition=Available deployments --selector=app=openebs-zfs-controller --namespace=openebs --timeout=300s
      kubectl wait --for=condition=Ready pods --selector=app=openebs-zfs-node --namespace=openebs --timeout=300s
      kubectl wait --for=condition=established crd/zfsvolumes.zfs.openebs.io crd/zfssnapshots.zfs.openebs.io crd/zfsnodes.zfs.openebs.io --namespace=openebs --timeout=300s
      wait_for_storageclass openebs-zfs 300 5
      
      log "OpenEBS ZFS is ready"

  # Helper to run tailscale operator apply via kpt
  - path: /usr/local/sbin/rke2-tailscale-operator-apply
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exuo pipefail

      if [[ $${#} -lt 1 ]]; then
        echo "Usage: rke2-tailscale-operator-apply <package-dir> [timeout]" >&2
        exit 64
      fi

      package_dir="$${1}"
      timeout="$${2:-3m}"

      source <(flox activate --dir /var/lib/rancher/rke2)

      kpt live apply "$${package_dir}" --reconcile-timeout="$${timeout}"

  # Helper to configure and apply tailscale connector manifests
  - path: /usr/local/sbin/rke2-tailscale-connector-deploy
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exuo pipefail

      if [[ $$# -lt 3 ]]; then
        echo "Usage: rke2-tailscale-connector-deploy <cluster-name> <vip-address> <lb-pool-cidr>" >&2
        exit 64
      fi

      cluster_name="$$1"
      vip_address="$$2"
      lb_pool_cidr="$$3"
      package_dir="/var/lib/incus-rke2-cluster/kpt-packages/mesh/tailscale"
      connector_manifest="$$package_dir/03-connector.yaml"

      source <(flox activate --dir /var/lib/rancher/rke2)

      success=0
      for i in $(seq 1 60); do
        if kubectl wait --for condition=established crd/connectors.tailscale.com --timeout=5s; then
          success=1
          break
        fi
        sleep 5
      done

      if [[ $$success -ne 1 ]]; then
        echo "[rke2-tailscale-connector] CRD connectors.tailscale.com not ready after 5m" >&2
        exit 1
      fi

      kpt fn eval "$$package_dir" --image ghcr.io/kptdev/krm-functions-catalog/apply-setters:v0.2 --match-kind Connector -- \
        cluster-name="$$cluster_name" \
        vip-address="$$vip_address" \
        lb-pool-cidr="$$lb_pool_cidr"

      kubectl apply -f "$$connector_manifest"

  # ZFS early umount service moved to systemd section

  # Network configuration service moved to systemd section

  # Network debug service moved to systemd section

  # Network wait service moved to systemd section

  # Network timeout configuration now handled by systemd drop-in in distrobuilder

  # =============================================================================
  # RKE2 CONFIGURATION FILES
  # =============================================================================

  # TLS Subject Alternative Names for RKE2 API server
  - path: /etc/rancher/rke2/config.yaml.d/tls-san.yaml
    content: |
      tls-san:
        - localhost
        - gateway
        - 0.0.0.0
        - 127.0.0.1
        - ${CLUSTER_VIP_GATEWAY_IP} # cluster VIP gateway
        - ${NODE_GATEWAY_IP} # node gateway
        # Note: VIP gateway removed - not a client endpoint
        # IPv6 addresses removed for IPv4-only configuration

  # Enable etcd metrics exposure
  - path: /etc/rancher/rke2/config.yaml.d/etcd-metrics.yaml
    content: |
      etcd-expose-metrics: true

  # Central dual-stack network CIDRs (applies to ALL nodes, control-plane & agents)
  # Formerly only in server layer; moved here so kubelet / components on every node
  # have consistent view.
  - path: /etc/rancher/rke2/config.yaml.d/network-cidrs.yaml
    content: |
      cluster-cidr: ${POD_NETWORK_CIDR}
      service-cidr: ${SERVICE_NETWORK_CIDR}
      kube-controller-manager-arg:
        - node-cidr-mask-size-ipv4=24

  # IPv4-only node IP configuration to prevent dual-stack auto-detection
  # Static DHCP lease ensures this matches the actual assigned IP
  - path: /etc/rancher/rke2/config.yaml.d/node-ip.yaml
    content: |
      node-ip: ${NODE_HOST_IP}

  # =============================================================================
  # KUBELET CONFIGURATION FILES
  # =============================================================================

  # Set systemd as cgroup driver
  - path: /var/lib/rancher/rke2/agent/etc/kubelet.conf.d/01-cgroup-override.conf
    content: |
      apiVersion: kubelet.config.k8s.io/v1beta1
      kind: KubeletConfiguration
      cgroupDriver: systemd

  # Disable aggressive image garbage collection
  - path: /var/lib/rancher/rke2/agent/etc/kubelet.conf.d/00-disable-gc.conf
    content: |
      apiVersion: kubelet.config.k8s.io/v1beta1
      kind: KubeletConfiguration
      kubelet-arg:
        imageGCHighThresholdPercent: 100
        imageGCLowThresholdPercent: 99

  # =============================================================================
  # CONTAINERD CONFIGURATION
  # =============================================================================

  # ZFS snapshotter configuration for containerd
  - path: /var/lib/rancher/rke2/agent/etc/containerd/config-v3.toml
    permissions: "0644"
    content: |
      {{ template "base" . }}

      [plugins."io.containerd.grpc.v1.cri".containerd]
        snapshotter = "zfs"

      [plugins."io.containerd.snapshotter.v1.zfs"]
        root_path = "/var/lib/rancher/rke2/agent/containerd/io.containerd.snapshotter.v1.zfs"

      [debug]
        level = "debug"

  # =============================================================================
  # FLOX ENVIRONMENT SETUP SCRIPTS
  # =============================================================================

  # Pre-installation script for environment setup
  - path: /usr/local/sbin/rke2-install-pre
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      : "Generate /etc/rancher/rke2/environment from init process early"
      mkdir -p /etc/rancher/rke2
      cat <<EoE> /etc/rancher/rke2/environment
      $( cat /proc/1/environ | tr '\0' '\n' )
      EoE

      LIBRARY_DIR="/var/lib/rancher/rke2"
      : "Configure direnv to use flox"
      direnv:config:generate() {
        mkdir -p "/root/.config/direnv/lib"
        curl -o \
          "/root/.config/direnv/lib/flox.sh" \
          "https://raw.githubusercontent.com/flox/flox-direnv/v1.1.0/direnv.rc"
        cat <<EoConfig | cut -c 3- > "/root/.config/direnv/direnv.toml"
        [whitelist]
        prefix= [ "/home", "/root", "/var/lib/cloud/seed/nocloud", "/var/lib/rancher/rke2", ]
      EoConfig
      }
      direnv:config:generate

      : "Preload the nocloud environment"
      [[ ! -d /var/lib/cloud/seed/nocloud/.flox ]] && \
        flox init --dir=/var/lib/cloud/seed/nocloud
      flox install \
        --dir=/var/lib/cloud/seed/nocloud dasel yq-go
      source <( flox activate --dir=/var/lib/cloud/seed/nocloud )

      cat > /var/lib/cloud/seed/nocloud/.envrc <<'EoEnvrc'
        log_status "Loading nocloud environment variables"

        # Variables are loaded directly in flox profile-common.sh
        # Just activate flox environment
        [[ "$FLOX_ENV_PROJECT" != "$PWD" ]] &&
          use flox
      EoEnvrc
      dasel -r toml -w yaml \
        < /var/lib/cloud/seed/nocloud/.flox/env/manifest.toml |
        yq eval '.profile = {"common": "source /var/lib/cloud/seed/nocloud/.flox/env/profile-common.sh"}' - |
        dasel --pretty -r yaml -w toml | tee /tmp/manifest.toml.$$ &&
        mv /tmp/manifest.toml.$$ \
          /var/lib/cloud/seed/nocloud/.flox/env/manifest.toml
      cat <<'EoFloxCommonProfile' | cut -c 3- | tee /var/lib/cloud/seed/nocloud/.flox/env/profile-common.sh
        : "Load environment variables from /etc/rancher/rke2/environment"
        set -a

        : "Source RKE2 environment file if available"
        [[ -f /etc/rancher/rke2/environment ]] && source /etc/rancher/rke2/environment

        if command -v ip >/dev/null; then
          CLUSTER_GATEWAY=$$(ip route show default 2>/dev/null | awk '/default via/ { print $$3; exit }' || true)
        fi

        set +a
      EoFloxCommonProfile
      source <( flox activate --dir=/var/lib/cloud/seed/nocloud )

      : "Initialize the flox environment for RKE2"
      [[ ! -d /var/lib/rancher/rke2/.flox ]] &&
        flox init --dir=/var/lib/rancher/rke2

      flox install \
        --dir=/var/lib/rancher/rke2 \
        ceph-client cilium-cli etcdctl helmfile \
        kubernetes-helm kubectl yq-go # override
      
      : "Install kpt v1 in isolated group to avoid dependency conflicts"
      flox install \
        --dir=/var/lib/rancher/rke2 \
        kpt

      : "Include cloud environment in RKE2 flox environment and configure groups"
      dasel -r toml -w yaml \
        < /var/lib/rancher/rke2/.flox/env/manifest.toml |
        yq eval '.include = {"environments": [{"dir": "/var/lib/cloud/seed/nocloud"}]}' - |
        yq eval '.install += {"nerdctl": {"pkg-path": "nerdctl", "version": "1.7.5", "pkg-group": "containerd-tools", "systems": ["aarch64-linux"]}}' - |
        yq eval '.install += {"krew": {"pkg-path": "krew", "pkg-group": "kubectl-tools"}}' - |
        yq eval '.install += {"kubectl-ai": {"pkg-path": "kubectl-ai", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-ktop": {"pkg-path": "kubectl-ktop", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-neat": {"pkg-path": "kubectl-neat", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-tree": {"pkg-path": "kubectl-tree", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-graph": {"pkg-path": "kubectl-graph", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-doctor": {"pkg-path": "kubectl-doctor", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-explore": {"pkg-path": "kubectl-explore", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-rook-ceph": {"pkg-path": "kubectl-rook-ceph", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"kubectl-view-secret": {"pkg-path": "kubectl-view-secret", "pkg-group": "kubectl-plugins"}}' - |
        yq eval '.install += {"tubekit": {"pkg-path": "tubekit", "pkg-group": "kubectl-tools"}}' - |
        yq eval '.install += {"yq-go": {"pkg-path": "yq-go", "pkg-group": "yaml-tools"}}' - |
        yq eval '.install += {"kpt": {"pkg-path": "kpt", "version": "1.0.0-beta.55", "pkg-group": "kpt-tools"}}' - |
        yq eval '.profile = {"common": "source /var/lib/rancher/rke2/.flox/env/profile-common.sh"}' - |
        dasel --pretty -r yaml -w toml | tee /tmp/manifest.toml.$$ &&
        mv /tmp/manifest.toml.$$ \
          /var/lib/rancher/rke2/.flox/env/manifest.toml
        cat <<'EoFloxCommonProfile' | cut -c 3- | tee /var/lib/rancher/rke2/.flox/env/profile-common.sh
        : "Load environment variables from /etc/rancher/rke2/environment"
        set -a
        
        : "Source RKE2 environment file (generated from Incus instance config)"
        [[ -f /etc/rancher/rke2/environment ]] && source /etc/rancher/rke2/environment

        : "Load RKE2-specific dynamic environment variables"
        ARCH="$$(dpkg --print-architecture)"
        [[ -r /etc/rancher/rke2/rke2.yaml ]] &&
          KUBECONFIG="/etc/rancher/rke2/rke2.yaml"

        : "Default cache for kubectl/kpt"
        KUBECACHEDIR="$${KUBECACHEDIR:-$${FLOX_RUNTIME_DIR:-/run/user/0}/kube-cache}"
        mkdir -p "$${KUBECACHEDIR}"

        : "Set KREW_ROOT if not already set"
        KREW_ROOT="$${KREW_ROOT:-/var/lib/rancher/rke2/krew}"

        : "Update PATH with RKE2 tools"
        PATH="/var/lib/rancher/rke2/bin:$$PATH:$${KREW_ROOT}/bin"

        set +a
      EoFloxCommonProfile

      : "Load the RKE2 envrc"
      source <( flox activate --dir /var/lib/rancher/rke2 )

      : "Initialize krew and install plugins"
      KREW_ROOT="/var/lib/rancher/rke2/krew"
      mkdir -p "$$KREW_ROOT"

      : "Install krew plugins using krew directly"
      for plugin in ctx ns; do
        krew install "$$plugin" || true
      done

  # RKE2 installation script
  - path: /usr/local/sbin/rke2-install
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      source <( flox activate --dir /var/lib/rancher/rke2 )

      : "Install the RKE2 server or agent binaries"
      curl -sfL https://get.rke2.io | env DEBUG=1 sh -

      : "Patch containerd to use systemd cgroup driver"
      if [ -f "$$CONTAINERD_CONFIG_FILE" ]; then
        sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' "$$CONTAINERD_CONFIG_FILE"
      fi

      : "Enable shared mount service"
      systemctl daemon-reload
      systemctl enable rke2-remount-shared

  # =============================================================================
  # SYSTEMD SERVICE UNITS
  # =============================================================================

  # RKE2 remount shared service moved to systemd section

  # Systemd drop-in configuration for kubeconfig generation
  # Note: Network configuration is handled directly in runcmd before RKE2 services start

  - path: /etc/systemd/system/rke2-server.service.d/kubeconfig.conf
    content: |
      [Service]
      ExecStartPost=/bin/sh -xc '/usr/local/sbin/rke2-tools-configuration-directories'
      ExecStartPost=/bin/sh -xc '/usr/local/sbin/rke2-vip-kubeconfig'

  - path: /etc/systemd/system/rke2-agent.service.d/kubeconfig.conf
    content: |
      [Service]
      ExecStartPost=/bin/sh -xc '/usr/local/sbin/rke2-tools-configuration-directories'
      ExecStartPost=/bin/sh -xc '/usr/local/sbin/rke2-vip-kubeconfig'

  # Control plane specific systemd drop-in for Cilium operator scaling
  # - path: /etc/systemd/system/rke2-server.service.d/cilium-operator-scaling.conf
  #   content: |
  #     [Service]
  #     ExecStartPost=/bin/sh -xc '/usr/local/sbin/rke2-cilium-operator-scaling'

  # =============================================================================
  # ENVIRONMENT CONFIGURATION FILES
  # =============================================================================

  # Simplified RKE2 environment configuration (variables now in flox profile)
  - path: /var/lib/rancher/rke2/.envrc
    permissions: "0644"
    content: |
      #!/usr/bin/env bash
      log_status "Loading RKE2 flox environment"

      # Variables are now defined in flox profile-common.sh
      # Just activate flox environment
      [[ "$${FLOX_ENV_PROJECT}" != "$${PWD}" ]] &&
        use flox

  # =============================================================================
  # SHELL CONFIGURATION FILES
  # =============================================================================

  # Root user zsh configuration
  - path: /root/.zshrc
    permissions: "0644"
    content: |
      #!/usr/bin/env zsh

      : "Define useful functions"
      journalctl:unit:follow() {
        local unit="$$1"
        journalctl --unit $$unit --follow --no-tail |
          tee /.logs.d/$${unit}.log
      }

      : "Configure completions"
      autoload -Uz compinit &&
        compinit
      command -v kubectl >/dev/null &&
        source <( kubectl completion zsh ) 2>/dev/null || true
      command -v helm >/dev/null &&
        source <( helm completion zsh ) 2>/dev/null || true

      : "Load direnv hook"
      source <( direnv hook zsh )

  # Bash completion for kubectl and helm
  - path: /etc/bash_completion.d/kube
    permissions: "0644"
    content: |
      #!/usr/bin/env -S bash
      source <( flox activate --dir /var/lib/rancher/rke2 )

      source <( kubectl completion bash ) 2>/dev/null || true
      source <( helm completion bash ) 2>/dev/null || true

  # =============================================================================
  # UTILITY SCRIPTS
  # =============================================================================

  # Route cleanup script to remove DHCP default routes from vmnet0
  - path: /usr/local/sbin/rke2-route-cleanup
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      # Log all operations
      exec > >(logger -t rke2-route-cleanup) 2>&1

      echo "=== RKE2 Route Cleanup at $(date) ==="

      echo "=== Routes Before Cleanup ==="
      ip route show || true

      # Remove default route from vmnet0 if it exists
      # vmnet0 should NEVER have a default route - it's cluster-internal only
      if ip route show default dev vmnet0 >/dev/null 2>&1; then
        echo "[+] Removing unwanted default route from vmnet0 (cluster-internal interface)"
        ip route del default dev vmnet0 || true
      else
        echo "[i] No default route on vmnet0 (correct)"
      fi

      # Verify lan0 has the default route
      if ! ip route show default dev lan0 >/dev/null 2>&1; then
        echo "[!] Warning: No default route via lan0 found (should be primary internet gateway)"
        echo "[+] Current routes:"
        ip route show
      else
        echo "[i] Default route via lan0 is properly configured (primary internet)"
      fi

      echo "=== Routes After Cleanup ==="
      ip route show || true

      echo "=== Route Cleanup Complete at $(date) ==="

  # Network wait script for proper timing
  - path: /usr/local/sbin/rke2-network-wait
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      # Log all operations
      exec > >(logger -t rke2-network-wait) 2>&1

      : "=== RKE2 Network Wait at $(date) ==="

      # Wait for networkd to be active
      while ! systemctl is-active systemd-networkd >/dev/null 2>&1; do
        : "[.] Waiting for systemd-networkd..."
        sleep 2
      done

      # Wait for interfaces to be configured
      for iface in vmnet0 lan0; do
        : "[+] Waiting for interface $$iface..."
        timeout=30
        while [ $$timeout -gt 0 ]; do
          if ip link show "$$iface" >/dev/null 2>&1 && \
             networkctl status "$$iface" | grep -q "State: configured\|routable" 2>/dev/null; then
            : "[i] Interface $$iface is ready"
            break
          fi
          : "[.] Waiting for $$iface (timeout: $$timeout)..."
          sleep 1
          timeout=$$((timeout - 1))
        done

        if [ $$timeout -eq 0 ]; then
          : "[!] Warning: Interface $$iface not ready after 30 seconds"
        fi
      done

      # Brief additional wait for routes to stabilize
      : "[+] Allowing routes to stabilize..."
      sleep 3

      : "=== Final Network Status ==="
      ip addr show || true
      : "=== Final Routes ==="
      ip route show || true

      : "=== Network Wait Complete at $(date) ==="

  # Network debugging script for troubleshooting boot timing
  - path: /usr/local/sbin/rke2-network-debug
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      echo "=== RKE2 Network Debug at $$(date) ==="

      echo "=== Interface Status ==="
      ip addr show || true

      echo "=== Route Table ==="
      ip route show || true

      echo "=== NetworkD Status ==="
      systemctl status systemd-networkd --no-pager || true

      echo "=== NetworkD Configuration ==="
      networkctl list || true
      networkctl status vmnet0 || true

      echo "=== Wait-Online Status ==="
      systemctl status systemd-networkd-wait-online --no-pager || true

      echo "=== Boot Analysis ==="
      systemd-analyze blame | head -10 || true

      echo "=== Network Wait Analysis ==="
      systemd-analyze critical-chain systemd-networkd-wait-online.service || true

      echo "=== End Debug at $$(date) ==="

  # Script to remount volumes as shared
  - path: /usr/local/sbin/rke2-remount-shared
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail
      mount --make-shared /
      mount --make-shared -t bpf bpf /sys/fs/bpf
      mount --make-shared /run

  # Main activation script for RKE2
  - path: /usr/local/sbin/rke2-activate
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      : "Configure system-wide DNS"
      ln -fs /run/systemd/resolve/resolv.conf /etc/resolv.conf

      : "Start and wait for the RKE2 installation to complete"
      systemctl enable --now rke2-install

      : "Load the RKE2 environment"
      source <( flox activate --dir /var/lib/rancher/rke2 )

      : "Load the RKE2 environment and generate the named units"
      /usr/local/sbin/rke2-enable-containerd-zfs-mount

      : "Enable and start the RKE2 service"
      systemctl --no-block --now \
        enable rke2-${NODE_TYPE}

  # Script to generate ZFS mount units for containerd
  - path: /usr/local/sbin/rke2-enable-containerd-zfs-mount
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      : "Load the RKE2 environment"
      source <( flox activate --dir /var/lib/rancher/rke2 )

      : "Generate systemd mount unit for containerd zfs snapshotter"
      UNIT=var-lib-rancher-rke2-agent-containerd-io.containerd.snapshotter.v1.zfs.mount
      cat <<EOF > /etc/systemd/system/$$UNIT
      [Unit]
      Description=Mount containerd zfs snapshotter directory for RKE2 (ZFS dataset)
      DefaultDependencies=no
      Before=cloud-init.service
      Before=rke2-${NODE_TYPE}.service

      [Mount]
      What=tank/rke2/control-nodes/${NODE_NAME}/containerd
      Where=/var/lib/rancher/rke2/agent/containerd/io.containerd.snapshotter.v1.zfs
      Type=zfs
      Options=defaults

      [Install]
      WantedBy=multi-user.target
      RequiredBy=rke2-${NODE_TYPE}.service
      EOF

      : "Enable the mount unit"
      systemctl daemon-reload
      systemctl enable "$$UNIT"

  # Dynamic Cilium operator scaling script for control plane nodes
  - path: /usr/local/sbin/rke2-cilium-operator-scaling
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      source <( flox activate --dir /var/lib/rancher/rke2 )

      : "Wait for at least one node to be ready"
      kubectl wait --for=condition=Ready \
        nodes --all --timeout=300s || exit 0

      : "Wait for Cilium DaemonSet to exist"
      kubectl wait \
        --for=jsonpath='{.metadata.name}'=cilium \
        daemonset/cilium -n kube-system \
        --timeout=300s || exit 0

      : "Wait for Cilium operator deployment to exist"
      kubectl wait \
        --for=jsonpath='{.metadata.name}'=cilium-operator \
        deployment/cilium-operator -n kube-system \
        --timeout=300s || exit 0

      : "Wait for Cilium DaemonSet to have at least one ready pod"
      kubectl wait \
        --for=jsonpath='{.status.numberReady}'=1 \
        daemonset/cilium -n kube-system \
        --timeout=300s || exit 0

      : "Dynamic Cilium Operator Scaling"
      count=$$(kubectl get nodes -l node-role.kubernetes.io/control-plane --no-headers | wc -l)
      case $$count in
      1)
        replicas=1;;
      2)
        replicas=2;;
      *)
        replicas=3;;
      esac

      : "Scaling cilium-operator to $$replicas replicas for $$count control plane nodes"
      kubectl scale deployment cilium-operator \
        -n kube-system --replicas=$$replicas

      : "Wait for cilium-operator rollout to complete"
      kubectl rollout status \
        deployment/cilium-operator -n kube-system \
        --timeout=1s || true

  # Script to create tool configuration directories
  - path: /usr/local/sbin/rke2-tools-configuration-directories
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      : "Create directories for tool configurations"
      mkdir -p /var/lib/rancher/rke2/helm/plugins
      mkdir -p /etc/rancher/rke2/helm
      mkdir -p /var/cache/rancher/rke2/helm/repository
      mkdir -p /var/lib/rancher/rke2/krew

  # Script to generate kubeconfig for VIP access
  - path: /usr/local/sbin/rke2-vip-kubeconfig
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -exu -o pipefail

      source <( flox activate --dir /var/lib/rancher/rke2 )

      : "Create working copy of kubeconfig"
      KUBECONFIG="/.kubeconfig.d/rke2-${CLUSTER_NAME}.yaml"

      mkdir -p $( dirname "$$KUBECONFIG" )
      cp /etc/rancher/rke2/rke2.yaml "$$KUBECONFIG"
      chmod 644 "$$KUBECONFIG"

      : "Apply modifications to working copy"
      yq --inplace --from-file=<(cat <<EoE
      .clusters[0].cluster.name = "${CLUSTER_NAME}" |
      .clusters[0].cluster.server = "https://${CLUSTER_VIP_GATEWAY_IP}:6443" |
      .clusters[0].name = "${CLUSTER_NAME}" |
      .contexts[0].context.cluster = "${CLUSTER_NAME}" |
      .contexts[0].context.namespace = "kube-system" |
      .contexts[0].context.user = "${CLUSTER_NAME}" |
      .contexts[0].name = "${CLUSTER_NAME}" |
      .users[0].name = "${CLUSTER_NAME}" |
      .current-context = "${CLUSTER_NAME}"
      EoE
      ) "$$KUBECONFIG"

  # Cilium validation script (available on all nodes, executed only on master via post-start-master.conf)
  - path: /usr/local/sbin/rke2-cilium-check
    permissions: "0755"
    content: |
      #!/usr/bin/env -S bash -xu -o pipefail
      source <( flox activate --dir /var/lib/rancher/rke2 )
      kubectl wait --for=condition=Ready nodes --all --timeout=300s || true
      kubectl wait --for=condition=Ready pods -l k8s-app=cilium -n kube-system --timeout=300s || true
      kubectl wait --for=condition=Available deployment/cilium-operator -n kube-system --timeout=300s || true
      cilium status --wait --wait-duration=300s || true
      kubectl get ciliumloadbalancerippool -o wide || true
      kubectl get svc control-plane-lb -n kube-system -o wide || true
      kubectl get endpoints control-plane-lb -n kube-system -o wide || true
      kubectl get ciliumBGPClusterConfig -o wide || true
      kubectl get ciliumBGPAdvertisement -o wide || true
      kubectl get ciliumL2AnnouncementPolicy -o wide || true

# =============================================================================
# SYSTEMD UNIT OVERRIDES (processed early in boot, before write_files)
# =============================================================================

## Converted former 'systemd:' units into explicit write_files + runcmd enable/mask (@codebase)
  # ---- Systemd unit files (converted from previous systemd: units) ----
  - path: /etc/systemd/system/rke2-network-debug.service
    permissions: "0644"
    content: |
      [Unit]
      Description=RKE2 Network Debug Logger
      After=systemd-networkd.service

      [Service]
      Type=oneshot
      ExecStart=/bin/bash -c 'echo "=== Network Debug at $$(date) ==="; ip addr show; echo "=== Routes ==="; ip route show; echo "=== NetworkD Status ==="; systemctl status systemd-networkd --no-pager; echo "=== NetworkCTL List ==="; networkctl list'
      RemainAfterExit=true
      StandardOutput=journal+console
      StandardError=journal+console

      [Install]
      WantedBy=multi-user.target
  - path: /etc/systemd/system/rke2-network-wait.service
    permissions: "0644"
    content: |
      [Unit]
      Description=RKE2 Network Wait Service
      After=systemd-networkd.service
      Before=rke2-server.service rke2-agent.service
      Wants=systemd-networkd.service

      [Service]
      Type=oneshot
      ExecStart=/usr/local/sbin/rke2-network-wait
      RemainAfterExit=true
      StandardOutput=journal+console
      StandardError=journal+console
      SuccessExitStatus=0 1

      [Install]
      WantedBy=multi-user.target
  - path: /etc/systemd/system/rke2-route-cleanup.service
    permissions: "0644"
    content: |
      [Unit]
      Description=RKE2 Route Cleanup Service - Remove DHCP default routes
      After=network-online.target systemd-networkd.service
      Wants=network-online.target systemd-networkd.service
      Before=rke2-server.service rke2-agent.service
      StartLimitIntervalSec=30

      [Service]
      Type=oneshot
      ExecStart=/usr/local/sbin/rke2-route-cleanup
      RemainAfterExit=true
      StandardOutput=journal+console
      StandardError=journal+console
      Restart=on-failure
      RestartSec=5
      StartLimitBurst=3

      [Install]
      WantedBy=multi-user.target
  - path: /etc/systemd/system/zfs-early-umount.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Early ZFS umount all datasets
      After=zfs-mount.service
      Before=basic.target
      DefaultDependencies=no

      [Service]
      Type=oneshot
      ExecStart=/usr/sbin/zfs umount -a

      [Install]
      WantedBy=basic.target
  - path: /etc/systemd/system/rke2-remount-shared.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Remount RKE2 required volumes as shared
      Before=rke2-server.service
      DefaultDependencies=no

      [Service]
      Type=oneshot
      ExecStart=/usr/local/sbin/rke2-remount-shared
      RemainAfterExit=true

      [Install]
      WantedBy=multi-user.target

  - path: /etc/systemd/system/rke2-install.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Run RKE2 Installation Script
      After=network-online.target systemd-networkd.service
      Wants=network-online.target systemd-networkd.service
      ConditionPathExists=!/etc/systemd/system/rke2-server.service
      ConditionPathExists=!/etc/systemd/system/rke2-agent.service

      [Service]
      Type=oneshot
      ExecStartPre=/usr/local/sbin/rke2-install-pre
      ExecStart=/usr/local/sbin/rke2-install
      RemainAfterExit=true
      StandardOutput=journal
      StandardError=journal

      [Install]
      WantedBy=multi-user.target

runcmd:
  - [ sysctl, -p, /etc/sysctl.d/99-disable-ipv6.conf ]
  - [ systemctl, daemon-reload ]
  - [ systemctl, enable,
      rke2-network-config.service,
      rke2-network-debug.service,
      rke2-network-wait.service,
      rke2-route-cleanup.service,
      zfs-early-umount.service,
      rke2-remount-shared.service,
      rke2-install.service ]
  # Start network configuration service immediately
  - [ systemctl, start, rke2-network-config.service ]
  - /usr/local/sbin/rke2-activate
